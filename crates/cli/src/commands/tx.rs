use std::time::SystemTime;

use alloy::primitives::U256;
use clap::Subcommand;
use rrelayer_core::common_types::PagingContext;
use rrelayer_core::{
    common_types::EvmAddress,
    relayer::types::RelayerId,
    transaction::{
        api::RelayTransactionRequest,
        types::{Transaction, TransactionData, TransactionId, TransactionSpeed, TransactionValue},
    },
};
use rrelayer_sdk::SDK;

use crate::{
    authentication::handle_authenticate, commands::error::TransactionError,
    commands::keystore::ProjectLocation,
};

#[derive(Subcommand)]
pub enum TxCommand {
    /// Get transaction by ID
    Get {
        /// The transaction id which is generated by rrelayer
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// Get transaction status by ID
    Status {
        /// The transaction id which is generated by rrelayer
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// List transactions for a relayer
    List {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,

        /// Filter by status (pending, sent, failed, success)
        #[arg(long)]
        status: Option<TxStatus>,
    },
    /// List pending and mempool transactions size
    Queue {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,
    },
    /// Cancel a transaction
    Cancel {
        /// The transaction id which is generated by rrelayer
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// Replace a transaction
    Replace {
        /// The transaction id which is generated by rrelayer
        #[clap(required = true)]
        tx_id: TransactionId,

        /// The transaction
        #[clap(required = true)]
        transaction: RelayTransactionRequest,
    },
    /// Send a new transaction
    Send {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,

        /// The transaction
        #[clap(required = true)]
        transaction: RelayTransactionRequest,
    },
    /// Withdraw tokens from the relayer to somewhere else
    Withdraw {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,

        /// Destination for the funds to go to
        #[clap(required = true)]
        to: EvmAddress,

        /// Amount to send
        #[clap(required = true)]
        amount: U256,

        /// The token address if you want an erc20/721 balance
        #[arg(long)]
        token: Option<EvmAddress>,
    },
    /// Fund tokens from a wallet to your relayer
    Fund {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,

        /// Amount to send
        #[clap(required = true)]
        amount: U256,

        /// The token address if you want an erc20/721 balance
        #[arg(long)]
        token: Option<EvmAddress>,
    },
}

#[derive(clap::ValueEnum, Clone)]
pub enum TxStatus {
    Pending,
    Sent,
    Failed,
    Success,
}

/// Handles transaction commands by dispatching to the appropriate handler function.
///
/// Routes transaction commands to their respective handlers based on the command type.
/// Supports getting, listing, canceling, replacing, sending transactions, as well as
/// withdrawal operations and queue status checking.
///
/// # Arguments
/// * `command` - The transaction command to execute
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Command executed successfully
/// * `Err(TransactionError)` - Command execution failed
pub async fn handle_tx(
    command: &TxCommand,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    match command {
        TxCommand::Get { tx_id } => handle_get(tx_id, project_path, sdk).await,
        TxCommand::Withdraw { relayer_id, to, amount, token: _ } => {
            handle_withdraw(relayer_id, to, amount, project_path, sdk).await
        }
        TxCommand::Status { tx_id } => handle_status(tx_id, project_path, sdk).await,
        TxCommand::List { relayer_id, status } => {
            handle_list(relayer_id, status, project_path, sdk).await
        }
        TxCommand::Queue { relayer_id } => handle_queue(relayer_id, project_path, sdk).await,
        TxCommand::Cancel { tx_id } => handle_cancel(tx_id, project_path, sdk).await,
        TxCommand::Replace { tx_id, transaction } => {
            handle_replace(tx_id, transaction, project_path, sdk).await
        }
        TxCommand::Send { relayer_id, transaction } => {
            handle_send(relayer_id, transaction, project_path, sdk).await
        }
        TxCommand::Fund { relayer_id: _, amount: _, token: _ } => {
            // TODO: Implement Fund command
            Err(TransactionError::CommandFailed("Fund command not yet implemented".to_string()))
        }
    }
}

/// Gets and displays details for a specific transaction.
///
/// Authenticates the user, fetches the transaction by ID, and displays
/// its details in a formatted view.
///
/// # Arguments
/// * `tx_id` - The unique identifier of the transaction to retrieve
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Transaction retrieved and displayed successfully
/// * `Err(TransactionError)` - Authentication failed or transaction not found
async fn handle_get(
    tx_id: &TransactionId,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let tx = sdk.transaction.get_transaction(tx_id).await?;
    if let Some(tx) = tx {
        log_transactions(vec![tx])?;
    } else {
        println!("Transaction {} not found.", tx_id);
    }
    Ok(())
}

/// Withdraws funds from a relayer to a specified address.
///
/// Authenticates the user and sends a transaction from the relayer to withdraw
/// the specified amount to the destination address. Uses fast transaction speed.
///
/// # Arguments
/// * `relayer_id` - The unique identifier of the relayer to withdraw from
/// * `to` - The destination address to send funds to
/// * `amount` - The amount to withdraw
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Withdrawal transaction sent successfully
/// * `Err(TransactionError)` - Authentication failed or transaction failed
async fn handle_withdraw(
    relayer_id: &RelayerId,
    to: &EvmAddress,
    amount: &U256,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let tx = sdk
        .transaction
        .send_transaction(
            relayer_id,
            &RelayTransactionRequest {
                to: *to,
                value: TransactionValue::new(*amount),
                data: TransactionData::empty(),
                speed: Some(TransactionSpeed::Fast),
                blobs: None,
                external_id: None,
            },
        )
        .await?;

    println!("Transaction sent..");
    println!("Transaction id: {}", tx.id);
    println!("Transaction hash: {}", tx.hash);

    Ok(())
}

/// Gets and displays the status of a specific transaction.
///
/// Authenticates the user, fetches the transaction status by ID, and displays
/// the current status and transaction hash if available.
///
/// # Arguments
/// * `tx_id` - The unique identifier of the transaction to check
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Status retrieved and displayed successfully
/// * `Err(TransactionError)` - Authentication failed or status check failed
async fn handle_status(
    tx_id: &TransactionId,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let status = sdk.transaction.get_transaction_status(tx_id).await?;
    match status {
        None => {
            println!("Can not find transaction id {}", tx_id)
        }
        Some(result) => {
            println!("Transaction status: {}", result.status);
            if let Some(hash) = result.hash {
                println!("Transaction hash: {}", hash);
            }
        }
    }

    Ok(())
}

/// Lists transactions for a specific relayer.
///
/// Authenticates the user and retrieves all transactions for the specified relayer.
/// Displays the transactions in a formatted view. Status filtering is not yet implemented.
///
/// # Arguments
/// * `relayer_id` - The unique identifier of the relayer to list transactions for
/// * `_status` - Optional status filter (not yet implemented)
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Transactions listed successfully
/// * `Err(TransactionError)` - Authentication failed or transaction retrieval failed
async fn handle_list(
    relayer_id: &RelayerId,
    // TODO: handle status filtering
    _status: &Option<TxStatus>,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let transactions = sdk
        .transaction
        .get_transactions(
            relayer_id,
            &PagingContext {
                // TODO: handle paging later
                limit: 1000,
                offset: 0,
            },
        )
        .await?;

    log_transactions(transactions.items)?;

    Ok(())
}

/// Displays the transaction queue status for a specific relayer.
///
/// Authenticates the user and retrieves both pending and mempool transaction counts
/// for the specified relayer. Displays the results in a formatted status box.
///
/// # Arguments
/// * `relayer_id` - The unique identifier of the relayer to check queue status for
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Queue status displayed successfully
/// * `Err(TransactionError)` - Authentication failed or queue status retrieval failed
async fn handle_queue(
    relayer_id: &RelayerId,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let (pending_result, mempool_result) = tokio::join!(
        sdk.transaction.get_transactions_pending_count(relayer_id),
        sdk.transaction.get_transactions_inmempool_count(relayer_id)
    );

    let pending_count = pending_result?;
    let mempool_count = mempool_result?;

    println!("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ TRANSACTION QUEUE STATUS");
    println!("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ Relayer ID:        {}", relayer_id);
    println!("â”‚ Pending:           {} transactions", pending_count);
    println!("â”‚ In Mempool:        {} transactions", mempool_count);
    println!("â”‚ Total Queued:      {} transactions", pending_count + mempool_count);
    println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    match (pending_count, mempool_count) {
        (0, 0) => println!("\nâœ… No transactions in queue"),
        (p, 0) if p > 0 => println!("\nâ³ {} transactions waiting to be sent", p),
        (0, m) if m > 0 => println!("\nðŸ”„ {} transactions in mempool", m),
        (p, m) => println!("\nðŸ“Š {} pending, {} in mempool", p, m),
    }

    Ok(())
}

/// Attempts to cancel a pending transaction.
///
/// Authenticates the user and attempts to cancel the specified transaction.
/// Returns success if cancellation worked, or a message if the transaction
/// cannot be cancelled (e.g., already mined).
///
/// # Arguments
/// * `tx_id` - The unique identifier of the transaction to cancel
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Cancellation attempt completed (check output for actual result)
/// * `Err(TransactionError)` - Authentication failed or cancellation request failed
async fn handle_cancel(
    tx_id: &TransactionId,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;
    println!("Canceling transaction: {}", tx_id);

    let cancelled = sdk.transaction.cancel_transaction(tx_id).await?;

    if cancelled {
        println!("Transaction cancelled..");
        return Ok(());
    }

    println!(
        "Transaction could not be cancelled this can be due to the other transaction has already been mined.."
    );

    Ok(())
}

/// Attempts to replace a pending transaction with a new one.
///
/// Authenticates the user and attempts to replace the specified transaction
/// with a new transaction request. Returns success if replacement worked,
/// or a message if the transaction cannot be replaced.
///
/// # Arguments
/// * `tx_id` - The unique identifier of the transaction to replace
/// * `transaction` - The new transaction request to replace with
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Replacement attempt completed (check output for actual result)
/// * `Err(TransactionError)` - Authentication failed or replacement request failed
async fn handle_replace(
    tx_id: &TransactionId,
    transaction: &RelayTransactionRequest,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;
    println!("Replacing transaction: {}", tx_id);

    let replaced = sdk.transaction.replace_transaction(tx_id, transaction).await?;

    if replaced {
        println!("Transaction replaced..");
        return Ok(());
    }

    println!(
        "Transaction could not be cancelled this can be due to the other transaction has already been mined.."
    );
    Ok(())
}

/// Sends a new transaction using the specified relayer.
///
/// Authenticates the user and sends the provided transaction request using
/// the specified relayer. Displays the transaction ID and hash upon success.
///
/// # Arguments
/// * `relayer_id` - The unique identifier of the relayer to use for sending
/// * `transaction` - The transaction request to send
/// * `project_path` - The project location containing configuration and keystores
/// * `sdk` - Mutable reference to the SDK for making API calls
///
/// # Returns
/// * `Ok(())` - Transaction sent successfully
/// * `Err(TransactionError)` - Authentication failed or transaction send failed
async fn handle_send(
    relayer_id: &RelayerId,
    transaction: &RelayTransactionRequest,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), TransactionError> {
    handle_authenticate(sdk, "account1", project_path).await?;
    println!("Sending transaction: {:?}", transaction);

    let tx = sdk.transaction.send_transaction(relayer_id, transaction).await?;

    println!("Transaction sent..");
    println!("Transaction id: {}", tx.id);
    println!("Transaction hash: {}", tx.hash);

    Ok(())
}

/// Displays transactions in either detailed single-transaction format or JSON list format.
///
/// For a single transaction, displays detailed information in a formatted box.
/// For multiple transactions, displays them as a JSON list with a summary.
///
/// # Arguments
/// * `transactions` - Vector of transactions to display
///
/// # Returns
/// * `Ok(())` - Transactions displayed successfully
/// * `Err(TransactionError)` - Failed to serialize transactions to JSON
fn log_transactions(transactions: Vec<Transaction>) -> Result<(), TransactionError> {
    if transactions.is_empty() {
        println!("No transactions found.");
        return Ok(());
    }

    if transactions.len() == 1 {
        // Keep the detailed single transaction view as-is
        let tx = &transactions[0];
        println!("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        println!("â”‚ TRANSACTION DETAILS");
        println!("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        println!("â”‚ ID:                {}", tx.id);
        println!("â”‚ Relayer:           {}", tx.relayer_id);
        println!("â”‚ Status:            {}", tx.status);
        println!("â”‚ From:              {}", tx.from);
        println!("â”‚ To:                {}", tx.to);
        println!("â”‚ Value:             {}", tx.value.into_inner().to_string());
        println!("â”‚ Data:              {}", tx.data.hex());
        println!("â”‚ Chain ID:          {}", tx.chain_id);
        println!("â”‚ Speed:             {}", tx.speed);
        println!("â”‚ Nonce:             {}", tx.nonce.into_inner());

        if let Some(gas_limit) = tx.gas_limit {
            println!("â”‚ Gas Limit:         {}", gas_limit.into_inner());
        }

        if let Some(hash) = &tx.known_transaction_hash {
            println!("â”‚ Tx Hash:           {}", hash);
        }

        if let Some(blobs) = &tx.blobs {
            println!("â”‚ Blobs:             {}", blobs.len());
        }

        println!("â”‚ Queued At:         {}", format_time(&tx.queued_at));
        println!("â”‚ Expires At:        {}", format_time(&tx.expires_at));

        if let Some(sent_at) = &tx.sent_at {
            println!("â”‚ Sent At:           {}", format_time(sent_at));
        }

        if let Some(mined_at) = &tx.mined_at {
            println!("â”‚ Mined At:          {}", format_time(mined_at));
        }

        if let Some(confirmed_at) = &tx.confirmed_at {
            println!("â”‚ Confirmed At:      {}", format_time(confirmed_at));
        }

        if let Some(gas) = &tx.sent_with_gas {
            println!(
                "â”‚ Sent With Gas:     Max Priority Fee: {}, Max Fee: {}",
                gas.max_priority_fee.into_u128(),
                gas.max_fee.into_u128()
            );
        }

        if let Some(blob_gas) = &tx.sent_with_blob_gas {
            println!("â”‚ Sent With Blob Gas: {:?}", blob_gas);
        }

        println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        return Ok(());
    }

    println!("{} Transactions:\n", transactions.len());

    let json_output = serde_json::to_string_pretty(&transactions)?;
    println!("{}", json_output);

    println!("\nUse 'transaction get <id>' to see more details about a specific transaction.");

    Ok(())
}

/// Formats a SystemTime as a human-readable UTC timestamp string.
///
/// Converts a SystemTime to a formatted string in "YYYY-MM-DD HH:MM:SS UTC" format.
/// Returns "Invalid time" if the time cannot be formatted.
///
/// # Arguments
/// * `time` - The SystemTime to format
///
/// # Returns
/// * Formatted time string or "Invalid time" if formatting fails
fn format_time(time: &SystemTime) -> String {
    match time.duration_since(SystemTime::UNIX_EPOCH) {
        Ok(duration) => {
            let dt = chrono::DateTime::<chrono::Utc>::from_timestamp(
                duration.as_secs() as i64,
                duration.subsec_nanos(),
            )
            .unwrap_or_default();
            dt.format("%Y-%m-%d %H:%M:%S UTC").to_string()
        }
        Err(_) => "Invalid time".to_string(),
    }
}
