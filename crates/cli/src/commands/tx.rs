use alloy::network::EthereumWallet;
use alloy::primitives::utils::parse_units;
use alloy::providers::{Provider, ProviderBuilder};
use alloy::signers::local::PrivateKeySigner;
use alloy::sol;
use alloy::sol_types::SolCall;
use chrono::{DateTime, Utc};
use clap::Subcommand;
use rrelayer_core::common_types::PagingContext;
use rrelayer_core::transaction::api::RelayTransactionRequest;
use rrelayer_core::{
    common_types::EvmAddress,
    relayer::RelayerId,
    transaction::types::{
        Transaction, TransactionData, TransactionId, TransactionSpeed, TransactionValue,
    },
};
use rrelayer_sdk::SDK;
use std::io::{self, Write};

use crate::commands::error::TransactionError;

sol! {
    #[sol(rpc)]
    interface IERC20 {
        function transfer(address to, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }
}

#[derive(Subcommand)]
pub enum TxCommand {
    /// Get transaction by ID
    Get {
        /// The transaction id which is generated by rrelayer
        #[arg(long, short = 't')]
        tx_id: TransactionId,
    },
    /// Get transaction status by ID
    Status {
        /// The transaction id which is generated by rrelayer
        #[arg(long, short = 't')]
        tx_id: TransactionId,
    },
    /// List transactions for a relayer
    List {
        /// Relayer ID
        #[arg(long, short = 'r')]
        relayer_id: RelayerId,

        /// Filter by status (pending, sent, failed, success)
        #[arg(long)]
        status: Option<TxStatus>,

        /// Number of results to return (default: 10)
        #[arg(long, default_value = "10")]
        limit: u32,

        /// Number of results to skip (default: 0)
        #[arg(long, default_value = "0")]
        offset: u32,
    },
    /// List pending and mempool transactions size
    Queue {
        /// Relayer ID
        #[arg(long, short = 'r')]
        relayer_id: RelayerId,
    },
    /// Cancel a transaction
    Cancel {
        /// The transaction id which is generated by rrelayer
        #[arg(long, short = 't')]
        tx_id: TransactionId,
    },
    /// Replace a transaction
    Replace {
        /// The transaction id which is generated by rrelayer
        #[arg(long, short = 't')]
        tx_id: TransactionId,

        /// The transaction data as JSON
        #[arg(long, short = 'd')]
        transaction: RelayTransactionRequest,
    },
    /// Send a new transaction
    Send {
        /// Relayer ID
        #[arg(long, short = 'r')]
        relayer_id: RelayerId,

        /// The transaction data as JSON
        #[arg(long, short = 'd')]
        transaction: RelayTransactionRequest,
    },
    /// Withdraw tokens from the relayer to somewhere else
    Withdraw {
        /// Relayer ID
        #[arg(long, short = 'r')]
        relayer_id: RelayerId,

        /// Destination for the funds to go to
        #[arg(long)]
        to: EvmAddress,

        /// Amount to send (e.g., "1.5" for 1.5 ETH or "100" for 100 tokens)
        #[arg(long, short = 'a')]
        amount: String,

        /// The token address if you want an erc20/721 balance
        #[arg(long)]
        token: Option<EvmAddress>,

        /// Number of decimals for the token (default: 18 for ETH)
        #[arg(long, default_value = "18")]
        decimals: u8,
    },
    /// Fund tokens from a wallet to your relayer
    Fund {
        /// Relayer ID
        #[arg(long, short = 'r')]
        relayer_id: RelayerId,

        /// Amount to send (e.g., "1.5" for 1.5 ETH or "100" for 100 tokens)
        #[arg(long, short = 'a')]
        amount: String,

        /// The token address if you want an erc20/721 balance
        #[arg(long)]
        token: Option<EvmAddress>,

        /// Number of decimals for the token (default: 18 for ETH)
        #[arg(long, default_value = "18")]
        decimals: u8,
    },
}

#[derive(clap::ValueEnum, Clone)]
pub enum TxStatus {
    Pending,
    Sent,
    Failed,
    Success,
}

pub async fn handle_tx(command: &TxCommand, sdk: &SDK) -> Result<(), TransactionError> {
    match command {
        TxCommand::Get { tx_id } => handle_get(tx_id, sdk).await,
        TxCommand::Withdraw { relayer_id, to, amount, token, decimals } => {
            handle_withdraw(relayer_id, to, amount, token, *decimals, sdk).await
        }
        TxCommand::Status { tx_id } => handle_status(tx_id, sdk).await,
        TxCommand::List { relayer_id, status, limit, offset } => {
            handle_list(relayer_id, status, *limit, *offset, sdk).await
        }
        TxCommand::Queue { relayer_id } => handle_queue(relayer_id, sdk).await,
        TxCommand::Cancel { tx_id } => handle_cancel(tx_id, sdk).await,
        TxCommand::Replace { tx_id, transaction } => handle_replace(tx_id, transaction, sdk).await,
        TxCommand::Send { relayer_id, transaction } => {
            handle_send(relayer_id, transaction, sdk).await
        }
        TxCommand::Fund { relayer_id, amount, token, decimals } => {
            handle_fund(relayer_id, amount, token, *decimals, sdk).await
        }
    }
}

async fn handle_get(tx_id: &TransactionId, sdk: &SDK) -> Result<(), TransactionError> {
    let tx = sdk.transaction.get(tx_id).await?;
    if let Some(tx) = tx {
        log_transactions(vec![tx])?;
    } else {
        println!("Transaction {} not found.", tx_id);
    }
    Ok(())
}

async fn handle_withdraw(
    relayer_id: &RelayerId,
    to: &EvmAddress,
    amount: &str,
    token: &Option<EvmAddress>,
    decimals: u8,
    sdk: &SDK,
) -> Result<(), TransactionError> {
    let amount_wei = parse_units(amount, decimals)
        .map_err(|e| {
            TransactionError::CommandFailed(format!("Invalid amount format '{}': {}", amount, e))
        })?
        .into();

    println!(
        "Withdrawing {} {} (raw: {} wei)",
        amount,
        if token.is_some() { "tokens" } else { "ETH" },
        amount_wei
    );

    match token {
        Some(token_address) => {
            let call = IERC20::transferCall { to: (*to).into(), amount: amount_wei };

            let tx = sdk
                .transaction
                .send(
                    relayer_id,
                    &RelayTransactionRequest {
                        to: *token_address,
                        value: TransactionValue::zero(),
                        data: TransactionData::new(call.abi_encode().into()),
                        speed: Some(TransactionSpeed::Fast),
                        blobs: None,
                        external_id: None,
                    },
                    None,
                )
                .await?;

            println!("ERC-20 token withdrawal transaction sent..");
            println!("Transaction id: {}", tx.id);
            println!("Transaction hash: {}", tx.hash);
        }
        None => {
            // Native ETH transfer
            let tx = sdk
                .transaction
                .send(
                    relayer_id,
                    &RelayTransactionRequest {
                        to: *to,
                        value: TransactionValue::new(amount_wei),
                        data: TransactionData::empty(),
                        speed: Some(TransactionSpeed::Fast),
                        blobs: None,
                        external_id: None,
                    },
                    None,
                )
                .await?;

            println!("ETH withdrawal transaction sent..");
            println!("Transaction id: {}", tx.id);
            println!("Transaction hash: {}", tx.hash);
        }
    }

    Ok(())
}

async fn handle_status(tx_id: &TransactionId, sdk: &SDK) -> Result<(), TransactionError> {
    let status = sdk.transaction.get_status(tx_id).await?;
    match status {
        None => {
            println!("Can not find transaction id {}", tx_id)
        }
        Some(result) => {
            println!("Transaction status: {}", result.status);
            if let Some(hash) = result.hash {
                println!("Transaction hash: {}", hash);
            }
        }
    }

    Ok(())
}

async fn handle_list(
    relayer_id: &RelayerId,
    // TODO: handle status filtering
    _status: &Option<TxStatus>,
    limit: u32,
    offset: u32,
    sdk: &SDK,
) -> Result<(), TransactionError> {
    let paging_context = PagingContext::new(limit, offset);
    let transactions = sdk.transaction.get_all(relayer_id, &paging_context).await?;

    log_transactions(transactions.items)?;

    if let Some(next) = &transactions.next {
        println!("Use --limit {} --offset {} to see more results", next.limit, next.offset);
    }

    Ok(())
}

async fn handle_queue(relayer_id: &RelayerId, sdk: &SDK) -> Result<(), TransactionError> {
    let (pending_result, mempool_result) = tokio::join!(
        sdk.transaction.get_pending_count(relayer_id),
        sdk.transaction.get_inmempool_count(relayer_id)
    );

    let pending_count = pending_result?;
    let mempool_count = mempool_result?;

    println!("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ TRANSACTION QUEUE STATUS");
    println!("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ Relayer ID:        {}", relayer_id);
    println!("â”‚ Pending:           {} transactions", pending_count);
    println!("â”‚ In Mempool:        {} transactions", mempool_count);
    println!("â”‚ Total Queued:      {} transactions", pending_count + mempool_count);
    println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    match (pending_count, mempool_count) {
        (0, 0) => println!("\nâœ… No transactions in queue"),
        (p, 0) if p > 0 => println!("\nâ³ {} transactions waiting to be sent", p),
        (0, m) if m > 0 => println!("\nðŸ”„ {} transactions in mempool", m),
        (p, m) => println!("\nðŸ“Š {} pending, {} in mempool", p, m),
    }

    Ok(())
}

async fn handle_cancel(tx_id: &TransactionId, sdk: &SDK) -> Result<(), TransactionError> {
    println!("Canceling transaction: {}", tx_id);

    let cancelled = sdk.transaction.cancel(tx_id, None).await?;

    if cancelled {
        println!("Transaction cancelled..");
        return Ok(());
    }

    println!(
        "Transaction could not be cancelled this can be due to the other transaction has already been mined.."
    );

    Ok(())
}

async fn handle_replace(
    tx_id: &TransactionId,
    transaction: &RelayTransactionRequest,
    sdk: &SDK,
) -> Result<(), TransactionError> {
    println!("Replacing transaction: {}", tx_id);

    let replaced = sdk.transaction.replace(tx_id, transaction, None).await?;

    if replaced {
        println!("Transaction replaced..");
        return Ok(());
    }

    println!(
        "Transaction could not be cancelled this can be due to the other transaction has already been mined.."
    );
    Ok(())
}

async fn handle_send(
    relayer_id: &RelayerId,
    transaction: &RelayTransactionRequest,
    sdk: &SDK,
) -> Result<(), TransactionError> {
    println!("Sending transaction: {:?}", transaction);

    let tx = sdk.transaction.send(relayer_id, transaction, None).await?;

    println!("Transaction sent..");
    println!("Transaction id: {}", tx.id);
    println!("Transaction hash: {}", tx.hash);

    Ok(())
}

async fn handle_fund(
    relayer_id: &RelayerId,
    amount: &str,
    token: &Option<EvmAddress>,
    decimals: u8,
    sdk: &SDK,
) -> Result<(), TransactionError> {
    let result = sdk.relayer.get(relayer_id).await?.ok_or_else(|| {
        TransactionError::CommandFailed(format!("Relayer {} not found", relayer_id))
    })?;

    let target_address = result.relayer.address;
    let chain_id = result.relayer.chain_id;

    let amount_wei = parse_units(amount, decimals)
        .map_err(|e| {
            TransactionError::CommandFailed(format!("Invalid amount format '{}': {}", amount, e))
        })?
        .into();

    let network = sdk.network.get_all().await?;
    let network = network.into_iter().find(|n| n.chain_id == chain_id).expect("Network not found");

    println!("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ FUNDING RELAYER");
    println!("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("â”‚ Relayer ID:        {}", relayer_id);
    println!("â”‚ Target Address:    {}", target_address);
    println!("â”‚ Chain ID:          {}", chain_id);

    match token {
        Some(token_address) => {
            println!("â”‚ Token:             {}", token_address);
            println!("â”‚ Amount:            {} tokens (raw: {} units)", amount, amount_wei);
            println!("â”‚ Decimals:          {}", decimals);
        }
        None => {
            println!("â”‚ Token:             ETH (native)");
            println!("â”‚ Amount:            {} ETH (raw: {} wei)", amount, amount_wei);
            println!("â”‚ Decimals:          {}", decimals);
        }
    }

    println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!();

    print!("Enter the private key of the funding wallet (will be hidden): ");
    io::stdout()
        .flush()
        .map_err(|e| TransactionError::CommandFailed(format!("IO error: {}", e)))?;

    let private_key = rpassword::read_password().map_err(|e| {
        TransactionError::CommandFailed(format!("Failed to read private key: {}", e))
    })?;

    if private_key.trim().is_empty() {
        return Err(TransactionError::CommandFailed("Private key cannot be empty".to_string()));
    }

    let signer = PrivateKeySigner::from_slice(
        &hex::decode(private_key.trim().trim_start_matches("0x")).map_err(|e| {
            TransactionError::CommandFailed(format!("Invalid private key format: {}", e))
        })?,
    )
    .map_err(|e| TransactionError::CommandFailed(format!("Failed to create signer: {}", e)))?;

    let from_address = signer.address();
    println!("Funding from address: {}", from_address);

    let wallet = EthereumWallet::from(signer);

    let rpc_url = network.provider_urls.first().expect("Providers not found").to_string();
    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .wallet(wallet)
        .on_builtin(&rpc_url)
        .await
        .map_err(|e| TransactionError::CommandFailed(format!("Failed to connect to RPC: {}", e)))?;

    println!("Connected to RPC at {}", rpc_url);

    let actual_chain_id = provider
        .get_chain_id()
        .await
        .map_err(|e| TransactionError::CommandFailed(format!("Failed to get chain ID: {}", e)))?;

    if actual_chain_id != u64::from(chain_id) {
        return Err(TransactionError::CommandFailed(format!(
            "Chain ID mismatch! Expected {}, got {}",
            chain_id, actual_chain_id
        )));
    }

    match token {
        Some(token_address) => {
            println!("Sending {} tokens to {}...", amount, target_address);

            let call =
                IERC20::transferCall { to: target_address.into_address(), amount: amount_wei };

            let tx_request = alloy::rpc::types::TransactionRequest::default()
                .to((*token_address).into())
                .input(call.abi_encode().into());

            let tx_hash = provider
                .send_transaction(tx_request)
                .await
                .map_err(|e| {
                    TransactionError::CommandFailed(format!(
                        "Failed to send ERC-20 transfer: {}",
                        e
                    ))
                })?
                .watch()
                .await
                .map_err(|e| {
                    TransactionError::CommandFailed(format!(
                        "Failed to wait for ERC-20 transfer: {}",
                        e
                    ))
                })?;

            println!("âœ… ERC-20 transfer sent!");
            println!("Transaction hash: {}", tx_hash);
        }
        None => {
            println!("Sending {} ETH to {}...", amount, target_address);

            let tx_request = alloy::rpc::types::TransactionRequest::default()
                .to((target_address.into_address()).into())
                .value(amount_wei);

            let tx_hash = provider
                .send_transaction(tx_request)
                .await
                .map_err(|e| {
                    TransactionError::CommandFailed(format!("Failed to send ETH transfer: {}", e))
                })?
                .watch()
                .await
                .map_err(|e| {
                    TransactionError::CommandFailed(format!(
                        "Failed to wait for ETH transfer: {}",
                        e
                    ))
                })?;

            println!("âœ… ETH transfer sent!");
            println!("Transaction hash: {}", tx_hash);
        }
    }

    println!("\nðŸ’° Funding complete! Your relayer should receive the funds shortly.");
    println!("Use 'rrelayer balance {}' to check the updated balance.", relayer_id);

    Ok(())
}

/// Displays transactions in either detailed single-transaction format or JSON list format.
///
/// For a single transaction, displays detailed information in a formatted box.
/// For multiple transactions, displays them as a JSON list with a summary.
///
/// # Arguments
/// * `transactions` - Vector of transactions to display
///
/// # Returns
/// * `Ok(())` - Transactions displayed successfully
/// * `Err(TransactionError)` - Failed to serialize transactions to JSON
fn log_transactions(transactions: Vec<Transaction>) -> Result<(), TransactionError> {
    if transactions.is_empty() {
        println!("No transactions found.");
        return Ok(());
    }

    if transactions.len() == 1 {
        let tx = &transactions[0];
        println!("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        println!("â”‚ TRANSACTION DETAILS");
        println!("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        println!("â”‚ ID:                {}", tx.id);
        println!("â”‚ Relayer:           {}", tx.relayer_id);
        println!("â”‚ Status:            {}", tx.status);
        println!("â”‚ From:              {}", tx.from);
        println!("â”‚ To:                {}", tx.to);
        println!("â”‚ Value:             {}", tx.value.into_inner().to_string());
        println!("â”‚ Data:              {}", tx.data.hex());
        println!("â”‚ Chain ID:          {}", tx.chain_id);
        println!("â”‚ Speed:             {}", tx.speed);
        println!("â”‚ Nonce:             {}", tx.nonce.into_inner());

        if let Some(gas_limit) = tx.gas_limit {
            println!("â”‚ Gas Limit:         {}", gas_limit.into_inner());
        }

        if let Some(hash) = &tx.known_transaction_hash {
            println!("â”‚ Tx Hash:           {}", hash);
        }

        if let Some(blobs) = &tx.blobs {
            println!("â”‚ Blobs:             {}", blobs.len());
        }

        println!("â”‚ Queued At:         {}", format_time(&tx.queued_at));
        println!("â”‚ Expires At:        {}", format_time(&tx.expires_at));

        if let Some(sent_at) = &tx.sent_at {
            println!("â”‚ Sent At:           {}", format_time(sent_at));
        }

        if let Some(mined_at) = &tx.mined_at {
            println!("â”‚ Mined At:          {}", format_time(mined_at));
        }

        if let Some(confirmed_at) = &tx.confirmed_at {
            println!("â”‚ Confirmed At:      {}", format_time(confirmed_at));
        }

        if let Some(gas) = &tx.sent_with_gas {
            println!(
                "â”‚ Sent With Gas:     Max Priority Fee: {}, Max Fee: {}",
                gas.max_priority_fee.into_u128(),
                gas.max_fee.into_u128()
            );
        }

        if let Some(blob_gas) = &tx.sent_with_blob_gas {
            println!("â”‚ Sent With Blob Gas: {:?}", blob_gas);
        }

        println!("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
        return Ok(());
    }

    println!("{} Transactions:\n", transactions.len());

    let json_output = serde_json::to_string_pretty(&transactions)?;
    println!("{}", json_output);

    println!("\nUse 'transaction get <id>' to see more details about a specific transaction.");

    Ok(())
}

fn format_time(time: &DateTime<Utc>) -> String {
    time.format("%Y-%m-%d %H:%M:%S UTC").to_string()
}
